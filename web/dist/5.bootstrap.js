(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[5],{

/***/ "./dft_iain.js":
/*!*********************!*\
  !*** ./dft_iain.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fourier_front_end__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fourier-front-end */ \"../pkg/fourier_front_end.js\");\n/* harmony import */ var _avatar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./avatar.js */ \"./avatar.js\");\n\n\n\n// animation ticker\nlet time = 0;\nlet path = [];\n\nfunction epicycles(x, y, rotation, fourier) {\n  // For each epicycle in the fourier series, we will draw a circle.\n  for (let i = 0; i < fourier.length; i++) {\n    let prev_x = x;\n    let prev_y = y;\n\n    const freq = fourier[i].freq;\n    // Scale down our drawing, by a factor of 100.\n    const radius = fourier[i].amp * 4;\n    const phase = fourier[i].phase;\n\n    x += radius * Math.cos(freq * time + phase + rotation);\n    y += radius * Math.sin(freq * time + phase + rotation);\n\n    // Circle\n    canvas.circle(prev_x, prev_y, radius);\n\n    // Perimeter point\n    canvas.circle(x, y, 1);\n\n    // Line from circle center to it perimeter.\n    canvas.line(prev_x, prev_y, x, y);\n  }\n  // Return the last x and y point from that epicycle sequence.\n  // We'll use this to draw a line from the end of the last epicycle to the path.\n  return [x, y];\n}\n\nfunction genFourier(d) {\n  let fourier = [];\n\n  const imaginaries = d.imaginary();\n  const amplitudes = d.amplitude();\n  const phases = d.phase();\n  const frequencies = d.frequency();\n\n  d.real().map((re, ix) => {\n    fourier.push({\n      re: re,\n      imag: imaginaries[ix],\n      amp: amplitudes[ix],\n      phase: phases[ix],\n      freq: frequencies[ix],\n    });\n  });\n  fourier = fourier.sort((a, b) => b.amp - a.amp);\n  return fourier;\n}\n\n// Requires a canvas element with id=\"canvas\"\nlet canvas = new fourier_front_end__WEBPACK_IMPORTED_MODULE_0__[\"Canvas\"](\"dft_iain_canvas\");\n\nlet centerX = canvas.width() / 2;\nlet centerY = canvas.height() / 2;\n\nlet input_signal = _avatar_js__WEBPACK_IMPORTED_MODULE_1__[\"logo\"];\n\n// This will \"decompose\" our input signal into its constituent waves.\nlet d = Object(fourier_front_end__WEBPACK_IMPORTED_MODULE_0__[\"compute_spectrum_js\"])({ sig: input_signal });\nlet fourier = genFourier(d);\n\nconst maxPathLength = fourier.length;\n\nfunction step() {\n  let draw = true;\n  canvas.clear();\n\n  // calculate middle of the canvas...\n  let x = centerX;\n  let y = centerY;\n\n  // Epicycles returns the last point in that sequence of epicycles.\n  let vx = epicycles(x, y, 0, fourier);\n\n  // Draw the wave.\n  const center_x = 100;\n  const center_y = 100;\n  // add to beginning.\n  path.unshift(vx);\n\n  if (path.length === maxPathLength + 5) {\n    // remove from end\n    path.pop();\n  }\n\n  let shape = new fourier_front_end__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"](\"dft_iain_canvas\");\n  let offset = 0;\n\n  shape.begin_shape(center_x, center_y);\n\n  for (let i = 0; i < path.length; i++) {\n    // check if subsequent points are nearby on the x axis, if they are far apart, move the pen to the new point without drawing it.\n    if (i < path.length - 2) {\n      if (Math.abs(path[i][0] - path[i + 1][0]) > 10) {\n        shape.move_to(path[i + 1][0] + offset, path[i + 1][1]);\n      } else {\n        shape.vertex(path[i][0] + offset, path[i][1]);\n      }\n    }\n  }\n\n  shape.end_shape();\n\n  const dt = (2 * Math.PI) / fourier.length;\n  time += dt;\n  window.requestAnimationFrame(step);\n}\n\nwindow.requestAnimationFrame(step);\n\n\n//# sourceURL=webpack:///./dft_iain.js?");

/***/ })

}]);